#include <stdbool.h>
#include <stdint.h>

#include "cpu.h"

static enum AddressMode instruction_modes[256] = {
    0x5, 0x6, 0x5, 0x6, 0xa, 0xa, 0xa, 0xa, 0x5, 0x4, 0x3, 0x4, 0x0, 0x0, 0x0,
    0x0, 0x9, 0x8, 0x5, 0x8, 0xb, 0xb, 0xb, 0xb, 0x5, 0x2, 0x5, 0x2, 0x1, 0x1,
    0x1, 0x1, 0x0, 0x6, 0x5, 0x6, 0xa, 0xa, 0xa, 0xa, 0x5, 0x4, 0x3, 0x4, 0x0,
    0x0, 0x0, 0x0, 0x9, 0x8, 0x5, 0x8, 0xb, 0xb, 0xb, 0xb, 0x5, 0x2, 0x5, 0x2,
    0x1, 0x1, 0x1, 0x1, 0x5, 0x6, 0x5, 0x6, 0xa, 0xa, 0xa, 0xa, 0x5, 0x4, 0x3,
    0x4, 0x0, 0x0, 0x0, 0x0, 0x9, 0x8, 0x5, 0x8, 0xb, 0xb, 0xb, 0xb, 0x5, 0x2,
    0x5, 0x2, 0x1, 0x1, 0x1, 0x1, 0x5, 0x6, 0x5, 0x6, 0xa, 0xa, 0xa, 0xa, 0x5,
    0x4, 0x3, 0x4, 0x7, 0x0, 0x0, 0x0, 0x9, 0x8, 0x5, 0x8, 0xb, 0xb, 0xb, 0xb,
    0x5, 0x2, 0x5, 0x2, 0x1, 0x1, 0x1, 0x1, 0x4, 0x6, 0x4, 0x6, 0xa, 0xa, 0xa,
    0xa, 0x5, 0x4, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0x9, 0x8, 0x5, 0x8, 0xb, 0xb,
    0xc, 0xc, 0x5, 0x2, 0x5, 0x2, 0x1, 0x1, 0x2, 0x2, 0x4, 0x6, 0x4, 0x6, 0xa,
    0xa, 0xa, 0xa, 0x5, 0x4, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0x9, 0x8, 0x5, 0x8,
    0xb, 0xb, 0xc, 0xc, 0x5, 0x2, 0x5, 0x2, 0x1, 0x1, 0x2, 0x2, 0x4, 0x6, 0x4,
    0x6, 0xa, 0xa, 0xa, 0xa, 0x5, 0x4, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0x9, 0x8,
    0x5, 0x8, 0xb, 0xb, 0xb, 0xb, 0x5, 0x2, 0x5, 0x2, 0x1, 0x1, 0x1, 0x1, 0x4,
    0x6, 0x4, 0x6, 0xa, 0xa, 0xa, 0xa, 0x5, 0x4, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0,
    0x9, 0x8, 0x5, 0x8, 0xb, 0xb, 0xb, 0xb, 0x5, 0x2, 0x5, 0x2, 0x1, 0x1, 0x1,
    0x1,
};

bool resolve_address(const struct Cpu* cpu, uint8_t opcode,
                     struct InstructionContext* ctx) {
  bool pages_crossed = false;
  ctx->address_mode = instruction_modes[opcode];
  switch (ctx->address_mode) {
    case kAddressModeAbsolute:
      ctx->address = read16(cpu, cpu->pc + 1, false);
      break;
    case kAddressModeAbsoluteX:
      ctx->address = read16(cpu, cpu->pc + 1, false) + cpu->x;
      pages_crossed = pages_differ(ctx->address - cpu->x, ctx->address);
      break;
    case kAddressModeAbsoluteY:
      ctx->address = read16(cpu, cpu->pc + 1, false) + cpu->y;
      pages_crossed = pages_differ(ctx->address - cpu->y, ctx->address);
      break;
    case kAddressModeAccumulator:
      ctx->address = 0;
      break;
    case kAddressModeImmediate:
      ctx->address = cpu->pc + 1;
      break;
    case kAddressModeImplied:
      ctx->address = 0;
      break;
    case kAddressModeIndexedIndirect:
      ctx->address = read16(
          cpu, cpu->bus->read(cpu->bus->ctx, cpu->pc + 1) + cpu->x, true);
      break;
    case kAddressModeIndirect:
      ctx->address =
          read16(cpu, cpu->bus->read(cpu->bus->ctx, cpu->pc + 1), true);
      break;
    case kAddressModeIndirectIndexed:
      ctx->address =
          read16(cpu, cpu->bus->read(cpu->bus->ctx, cpu->pc + 1), true) +
          cpu->y;
      pages_crossed = pages_differ(ctx->address - cpu->y, ctx->address);
      break;
    case kAddressModeRelative:
      ctx->address = cpu->bus->read(cpu->bus->ctx, cpu->pc + 1);
      if (ctx->address >= 0x80) {
        ctx->address -= 0x100;
      }

      ctx->address += cpu->pc + 2;
      break;
    case kAddressModeZeroPage:
      ctx->address = cpu->bus->read(cpu->bus->ctx, cpu->pc + 1);
      break;
    case kAddressModeZeroPageX:
      ctx->address =
          (cpu->bus->read(cpu->bus->ctx, cpu->pc + 1) + cpu->x) & 0xff;
      break;
    case kAddressModeZeroPageY:
      ctx->address =
          (cpu->bus->read(cpu->bus->ctx, cpu->pc + 1) + cpu->y) & 0xff;
      break;
  }

  return pages_crossed;
}
