#include "cpu.h"

#include <stdbool.h>
#include <stdint.h>

#include "e6502.h"

bool get_flag(const struct Cpu* cpu, enum Flag flag) {
  return (cpu->p & flag) > 0 ? 1 : 0;
}

void set_flag(struct Cpu* cpu, enum Flag flag, bool value) {
  if (value) {
    cpu->p |= flag;
  } else {
    cpu->p &= ~flag;
  }
}

bool pages_differ(uint16_t page_a, uint16_t page_b) {
  return (page_a & 0xff00) != (page_b & 0xff00);
}

void push8(struct Cpu* cpu, uint8_t value) {
  uint16_t address = 0x100 | cpu->s--;
  cpu->bus->write(cpu->bus->ctx, address, value);
}

uint8_t pull8(struct Cpu* cpu) {
  uint16_t address = 0x100 | ++cpu->s;
  return cpu->bus->read(cpu->bus->ctx, address);
}

void push16(struct Cpu* cpu, uint16_t value) {
  push8(cpu, value >> 8);
  push8(cpu, value & 0xff);
}

uint16_t pull16(struct Cpu* cpu) {
  uint16_t lo = pull8(cpu);
  uint16_t hi = pull8(cpu);
  return hi << 8 | lo;
}

uint16_t read16(const struct Cpu* cpu, uint16_t address, bool emulate_bug) {
  uint16_t lo = cpu->bus->read(cpu->bus->ctx, address);
  uint16_t hi =
      emulate_bug ? cpu->bus->read(cpu->bus->ctx, (address & 0xff00) |
                                                      ((address + 1) & 0x00ff))
                  : cpu->bus->read(cpu->bus->ctx, address + 1);
  return hi << 8 | lo;
}

static uint8_t instruction_sizes[256] = {
    0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x2, 0x1, 0x0, 0x3, 0x3, 0x3,
    0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x3, 0x1, 0x0, 0x3, 0x3,
    0x3, 0x0, 0x3, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x2, 0x1, 0x0, 0x3,
    0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x3, 0x1, 0x0,
    0x3, 0x3, 0x3, 0x0, 0x1, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x2, 0x1,
    0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x3,
    0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x1, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1,
    0x2, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0,
    0x1, 0x3, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2,
    0x0, 0x1, 0x0, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2,
    0x2, 0x0, 0x1, 0x3, 0x1, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x2,
    0x2, 0x2, 0x0, 0x1, 0x2, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0, 0x0,
    0x2, 0x2, 0x2, 0x0, 0x1, 0x3, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2, 0x0,
    0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x2, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2, 0x2,
    0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x3, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0, 0x2,
    0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x2, 0x1, 0x0, 0x3, 0x3, 0x3, 0x0,
    0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x1, 0x3, 0x1, 0x0, 0x3, 0x3, 0x3,
    0x0,
};

static const char* instruction_names[256] = {
    "BRK", "ORA", "KIL", "SLO", "NOP", "ORA", "ASL", "SLO", "PHP", "ORA", "ASL",
    "ANC", "NOP", "ORA", "ASL", "SLO", "BPL", "ORA", "KIL", "SLO", "NOP", "ORA",
    "ASL", "SLO", "CLC", "ORA", "NOP", "SLO", "NOP", "ORA", "ASL", "SLO", "JSR",
    "AND", "KIL", "RLA", "BIT", "AND", "ROL", "RLA", "PLP", "AND", "ROL", "ANC",
    "BIT", "AND", "ROL", "RLA", "BMI", "AND", "KIL", "RLA", "NOP", "AND", "ROL",
    "RLA", "SEC", "AND", "NOP", "RLA", "NOP", "AND", "ROL", "RLA", "RTI", "EOR",
    "KIL", "SRE", "NOP", "EOR", "LSR", "SRE", "PHA", "EOR", "LSR", "ALR", "JMP",
    "EOR", "LSR", "SRE", "BVC", "EOR", "KIL", "SRE", "NOP", "EOR", "LSR", "SRE",
    "CLI", "EOR", "NOP", "SRE", "NOP", "EOR", "LSR", "SRE", "RTS", "ADC", "KIL",
    "RRA", "NOP", "ADC", "ROR", "RRA", "PLA", "ADC", "ROR", "ARR", "JMP", "ADC",
    "ROR", "RRA", "BVS", "ADC", "KIL", "RRA", "NOP", "ADC", "ROR", "RRA", "SEI",
    "ADC", "NOP", "RRA", "NOP", "ADC", "ROR", "RRA", "NOP", "STA", "NOP", "SAX",
    "STY", "STA", "STX", "SAX", "DEY", "NOP", "TXA", "XAA", "STY", "STA", "STX",
    "SAX", "BCC", "STA", "KIL", "AHX", "STY", "STA", "STX", "SAX", "TYA", "STA",
    "TXS", "TAS", "SHY", "STA", "SHX", "AHX", "LDY", "LDA", "LDX", "LAX", "LDY",
    "LDA", "LDX", "LAX", "TAY", "LDA", "TAX", "LAX", "LDY", "LDA", "LDX", "LAX",
    "BCS", "LDA", "KIL", "LAX", "LDY", "LDA", "LDX", "LAX", "CLV", "LDA", "TSX",
    "LAS", "LDY", "LDA", "LDX", "LAX", "CPY", "CMP", "NOP", "DCP", "CPY", "CMP",
    "DEC", "DCP", "INY", "CMP", "DEX", "AXS", "CPY", "CMP", "DEC", "DCP", "BNE",
    "CMP", "KIL", "DCP", "NOP", "CMP", "DEC", "DCP", "CLD", "CMP", "NOP", "DCP",
    "NOP", "CMP", "DEC", "DCP", "CPX", "SBC", "NOP", "ISC", "CPX", "SBC", "INC",
    "ISC", "INX", "SBC", "NOP", "SBC", "CPX", "SBC", "INC", "ISC", "BEQ", "SBC",
    "KIL", "ISC", "NOP", "SBC", "INC", "ISC", "SED", "SBC", "NOP", "ISC", "NOP",
    "SBC", "INC", "ISC",
};

void fetch_instruction(const struct Bus* bus, uint16_t address,
                       struct Instruction* instr) {
  if (!bus || !instr) {
    return;
  }

  instr->bytes[0] = bus->read(bus->ctx, address);
  instr->num_bytes = instruction_sizes[instr->bytes[0]];
  if (instr->num_bytes >= 2) {
    instr->bytes[1] = bus->read(bus->ctx, address + 1);
  }

  if (instr->num_bytes == 3) {
    instr->bytes[2] = bus->read(bus->ctx, address + 2);
  }

  instr->opcode = instruction_names[instr->bytes[0]];
}

bool cpu_init(struct Cpu* cpu, const struct Bus* bus) {
  if (!cpu || !bus) {
    return false;
  }

  cpu->a = 0;
  cpu->x = 0;
  cpu->y = 0;
  cpu->interrupt = kInterruptTypeNone;
  cpu->bus = bus;

  cpu_reset(cpu);

  return true;
}

void cpu_reset(struct Cpu* cpu) {
  cpu->s = 0xfd;
  cpu->p = 0x24;
  cpu->pc = read16(cpu, 0xfffc, false);
}

static uint8_t instruction_cycles[256] = {
    0x7, 0x6, 0x2, 0x8, 0x3, 0x3, 0x5, 0x5, 0x3, 0x2, 0x2, 0x2, 0x4, 0x4, 0x6,
    0x6, 0x2, 0x5, 0x2, 0x8, 0x4, 0x4, 0x6, 0x6, 0x2, 0x4, 0x2, 0x7, 0x4, 0x4,
    0x7, 0x7, 0x6, 0x6, 0x2, 0x8, 0x3, 0x3, 0x5, 0x5, 0x4, 0x2, 0x2, 0x2, 0x4,
    0x4, 0x6, 0x6, 0x2, 0x5, 0x2, 0x8, 0x4, 0x4, 0x6, 0x6, 0x2, 0x4, 0x2, 0x7,
    0x4, 0x4, 0x7, 0x7, 0x6, 0x6, 0x2, 0x8, 0x3, 0x3, 0x5, 0x5, 0x3, 0x2, 0x2,
    0x2, 0x3, 0x4, 0x6, 0x6, 0x2, 0x5, 0x2, 0x8, 0x4, 0x4, 0x6, 0x6, 0x2, 0x4,
    0x2, 0x7, 0x4, 0x4, 0x7, 0x7, 0x6, 0x6, 0x2, 0x8, 0x3, 0x3, 0x5, 0x5, 0x4,
    0x2, 0x2, 0x2, 0x5, 0x4, 0x6, 0x6, 0x2, 0x5, 0x2, 0x8, 0x4, 0x4, 0x6, 0x6,
    0x2, 0x4, 0x2, 0x7, 0x4, 0x4, 0x7, 0x7, 0x2, 0x6, 0x2, 0x6, 0x3, 0x3, 0x3,
    0x3, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x4, 0x4, 0x2, 0x6, 0x2, 0x6, 0x4, 0x4,
    0x4, 0x4, 0x2, 0x5, 0x2, 0x5, 0x5, 0x5, 0x5, 0x5, 0x2, 0x6, 0x2, 0x6, 0x3,
    0x3, 0x3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x4, 0x4, 0x2, 0x5, 0x2, 0x5,
    0x4, 0x4, 0x4, 0x4, 0x2, 0x4, 0x2, 0x4, 0x4, 0x4, 0x4, 0x4, 0x2, 0x6, 0x2,
    0x8, 0x3, 0x3, 0x5, 0x5, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x2, 0x5,
    0x2, 0x8, 0x4, 0x4, 0x6, 0x6, 0x2, 0x4, 0x2, 0x7, 0x4, 0x4, 0x7, 0x7, 0x2,
    0x6, 0x2, 0x8, 0x3, 0x3, 0x5, 0x5, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6,
    0x2, 0x5, 0x2, 0x8, 0x4, 0x4, 0x6, 0x6, 0x2, 0x4, 0x2, 0x7, 0x4, 0x4, 0x7,
    0x7,
};

static uint8_t instruction_page_cycles[256] = {
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0,
    0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
    0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0,
    0x0,
};

uint8_t cpu_step(struct Cpu* cpu, uint16_t* address, uint8_t* cycles) {
  if (cycles) {
    *cycles = 0;
  }

  switch (cpu->interrupt) {
    case kInterruptTypeNmi:
      push16(cpu, cpu->pc);
      push8(cpu, cpu->p | 0x10);
      cpu->pc = read16(cpu, 0xfffa, false);
      set_flag(cpu, kFlagInterrupt, true);
      if (cycles) {
        *cycles = 7;
      }

      break;
    case kInterruptTypeIrq:
      push16(cpu, cpu->pc);
      push8(cpu, cpu->p | 0x10);
      cpu->pc = read16(cpu, 0xfffe, false);
      set_flag(cpu, kFlagInterrupt, true);
      if (cycles) {
        *cycles = 7;
      }

      break;
    default:
      break;
  }

  cpu->interrupt = kInterruptTypeNone;
  uint8_t opcode = cpu->bus->read(cpu->bus->ctx, cpu->pc);

  struct InstructionContext ctx = {
      .pc = cpu->pc,
  };

  bool pages_crossed = resolve_address(cpu, opcode, &ctx);
  if (address) {
    *address = ctx.address;
  }

  cpu->pc += instruction_sizes[opcode];
  if (cycles) {
    *cycles += instruction_cycles[opcode];
    if (pages_crossed) {
      *cycles += instruction_page_cycles[opcode];
    }
  }

  instructions[opcode](cpu, &ctx);
  if (cycles) {
    *cycles += ctx.cycles;
  }

  return opcode;
}

void cpu_trigger_nmi(struct Cpu* cpu) { cpu->interrupt = kInterruptTypeNmi; }

void cpu_trigger_irq(struct Cpu* cpu) {
  if (!get_flag(cpu, kFlagInterrupt)) {
    cpu->interrupt = kInterruptTypeIrq;
  }
}
